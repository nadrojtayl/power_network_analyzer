
<!DOCTYPE html>
<html>
<head>
	
	<title>Quick Start - Leaflet</title>

	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ==" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js" integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw==" crossorigin=""></script>

    <script
  src="https://code.jquery.com/jquery-3.2.1.js"
  integrity="sha256-DZAnKJ/6XZ9si04Hgrsxu/8s717jcIzLy3oi35EouyE="
  crossorigin="anonymous"></script>
 



	
</head>
<body>



<div id="mapid" style="width: 1800px; height: 1200px;"></div>

<script>

/**
 * Graham's Scan Convex Hull Algorithm
 * @desc An implementation of the Graham's Scan Convex Hull algorithm in JavaScript.
 * @author Brian Barnett, brian@3kb.co.uk, http://brianbar.net/ || http://3kb.co.uk/
 * @version 1.0.5
 */
function ConvexHullGrahamScan() {
    this.anchorPoint = undefined;
    this.reverse = false;
    this.points = [];
}

ConvexHullGrahamScan.prototype = {

    constructor: ConvexHullGrahamScan,

    Point: function (x, y) {
        this.x = x;
        this.y = y;
    },

    _findPolarAngle: function (a, b) {
        var ONE_RADIAN = 57.295779513082;
        var deltaX, deltaY;

        //if the points are undefined, return a zero difference angle.
        if (!a || !b) return 0;

        deltaX = (b.x - a.x);
        deltaY = (b.y - a.y);

        if (deltaX == 0 && deltaY == 0) {
            return 0;
        }

        var angle = Math.atan2(deltaY, deltaX) * ONE_RADIAN;

        if (this.reverse){
            if (angle <= 0) {
                angle += 360;
            }
        }else{
            if (angle >= 0) {
                angle += 360;
            }
        }

        return angle;
    },

    addPoint: function (x, y) {
        //Check for a new anchor
        var newAnchor =
            (this.anchorPoint === undefined) ||
            ( this.anchorPoint.y > y ) ||
            ( this.anchorPoint.y === y && this.anchorPoint.x > x );

        if ( newAnchor ) {
            if ( this.anchorPoint !== undefined ) {
                this.points.push(new this.Point(this.anchorPoint.x, this.anchorPoint.y));
            }
            this.anchorPoint = new this.Point(x, y);
        } else {
            this.points.push(new this.Point(x, y));
        }
    },

    _sortPoints: function () {
        var self = this;

        return this.points.sort(function (a, b) {
            var polarA = self._findPolarAngle(self.anchorPoint, a);
            var polarB = self._findPolarAngle(self.anchorPoint, b);

            if (polarA < polarB) {
                return -1;
            }
            if (polarA > polarB) {
                return 1;
            }

            return 0;
        });
    },

    _checkPoints: function (p0, p1, p2) {
        var difAngle;
        var cwAngle = this._findPolarAngle(p0, p1);
        var ccwAngle = this._findPolarAngle(p0, p2);

        if (cwAngle > ccwAngle) {

            difAngle = cwAngle - ccwAngle;

            return !(difAngle > 180);

        } else if (cwAngle < ccwAngle) {

            difAngle = ccwAngle - cwAngle;

            return (difAngle > 180);

        }

        return true;
    },

    getHull: function () {
        var hullPoints = [],
            points,
            pointsLength;

        this.reverse = this.points.every(function(point){
            return (point.x < 0 && point.y < 0);
        });

        points = this._sortPoints();
        pointsLength = points.length;

        //If there are less than 3 points, joining these points creates a correct hull.
        if (pointsLength < 3) {
            points.unshift(this.anchorPoint);
            return points;
        }

        //move first two points to output array
        hullPoints.push(points.shift(), points.shift());

        //scan is repeated until no concave points are present.
        while (true) {
            var p0,
                p1,
                p2;

            hullPoints.push(points.shift());

            p0 = hullPoints[hullPoints.length - 3];
            p1 = hullPoints[hullPoints.length - 2];
            p2 = hullPoints[hullPoints.length - 1];

            if (this._checkPoints(p0, p1, p2)) {
                hullPoints.splice(hullPoints.length - 2, 1);
            }

            if (points.length == 0) {
                if (pointsLength == hullPoints.length) {
                    //check for duplicate anchorPoint edge-case, if not found, add the anchorpoint as the first item.
                    var ap = this.anchorPoint;
                    //remove any udefined elements in the hullPoints array.
                    hullPoints = hullPoints.filter(function(p) { return !!p; });
                    if (!hullPoints.some(function(p){
                            return(p.x == ap.x && p.y == ap.y);
                        })) {
                        hullPoints.unshift(this.anchorPoint);
                    }
                    return hullPoints;
                }
                points = hullPoints;
                pointsLength = points.length;
                hullPoints = [];
                hullPoints.push(points.shift(), points.shift());
            }
        }
    }
};



</script>

<script>


	var mymap = L.map('mapid').setView([51.505, -0.09], 13);


	L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', {
		maxZoom: 18,
		attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
			'<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
			'Imagery Â© <a href="http://mapbox.com">Mapbox</a>',
		id: 'mapbox.streets'
	}).addTo(mymap);

	// L.marker([51.5, -0.09]).addTo(mymap)
	// 	.bindPopup("<b>Hello world!</b><br />I am a popup.").openPopup();

	// L.circle([51.508, -0.11], 500, {
	// 	color: 'red',
	// 	fillColor: '#f03',
	// 	fillOpacity: 0.5
	// }).addTo(mymap).bindPopup("I am a circle.");

	L.polygon([
		[51.509, -0.08],
		[51.503, -0.06],
		[51.51, -0.047]
	],{color: 'red'}).addTo(mymap)	

	// var popup = L.popup();

	class Building{
		constructor(metadata,nodes,tags,polygon){
			this.metadata = metadata;
			this.nodes = nodes;
			this.tags = tags;
			this.polygon = polygon;
			this.center_lat_long = get_center(this.nodes);
			this.draw = function(){
				this.polygon.addTo(mymap);
			}
		}
	}

	var buildings = [];
	var substations = [];
	var guessed_substations = [];
	var polygons = [];
	var polylines = [];
	var power_data;
	var polygon;
	var building;

	var populate_way = function(way_object,index){
		var nodes = [];
		var latlongs = way_object["node_references"].forEach(function(ref){
			if(ref["metadata"] !== undefined){
				var lat = parseFloat(ref["metadata"]["lat"]);
				var lon = parseFloat(ref["metadata"]["lon"].replace("/",""));

				nodes.push([lat,lon])
			}
		})
		way_object["tags"]["number"] = index;
		var tags_string = JSON.stringify(way_object["tags"]);
		if(way_object["tags"]["power"] !== undefined){
			if(way_object["tags"]["power"] !== "substation"){
				// console.log("Adding polyline " + JSON.stringify(nodes))
				polyline = L.polyline(nodes).addTo(mymap);
				polylines.push(polyline)
				polyline.bindPopup(tags_string);
			} else {
				polygon = L.polygon(nodes,{color: 'red'})
				polygons.push(polygon)
				polygon.bindPopup(tags_string);
				building = new Building(way_object["metadata"],nodes,way_object["tags"],polygon)
				building["buildings_served"] = [];
				substations.push(building);
			}
		} else {
			polygon = L.polygon(nodes,{color: 'green'})
			polygons.push(polygon)
			polygon.bindPopup(tags_string);
			building = new Building(way_object["metadata"],nodes,way_object["tags"],polygon)
			buildings.push(building);
		}


	}
	var bounds;
	var left;
	var bottom;
	var right;
	var top;
	

	$.get("http://localhost:3000/latlong",function(data){
		
		bounds = JSON.parse(data);
		// console.log(bounds[0]);
		// console.log(data);
		mymap.fitBounds(bounds);

	})

	var grid_boxes;

	var draw_grid = function(boxes_array){
		// console.log("ARR" + boxes_array);
		var left;
		var bottom;
		var right;
		var top;
		
		left = boxes_array[0];
		bottom = boxes_array[1];
		right = boxes_array[2];
		top = boxes_array[3];
		// console.log("FIRST" + left)
		var bound_box = [
			[top,left],
			[top,right],
			[bottom,right],
			[bottom,left],
			[top,left]

		]
		 // console.log("BOX AFTER" + bound_box);

		L.polygon(bound_box).addTo(mymap)


	}

	$.get("http://localhost:3000/boxes",function(data){
		// console.log("HERE1")
		boxes = JSON.parse(data);
		// console.log("boxes" + boxes);
		grid_boxes = boxes;
		boxes.forEach(function(box){
			// console.log('BOX' + typeof box);
			// draw_grid(box);
		})
		// console.log(data);
		

	})

	$.get("http://localhost:3000/data",function(data){

		if(typeof data !== "string"){
			power_data = data;
		} else {
			power_data = JSON.parse(data);
		}
		// console.log(data);
		

	})

</script>
<script>
//clustering algorithm for building perims
	var add_perimeters_to_buildings = function(){
		buildings.forEach(function(building){
			building["perimeter"] = get_perimeter(building["nodes"]);
		})
	}


 	// console.log(segment_length([1,2],[2,3]));

 	var get_percentage_of_differences = function(arr){
 		var percentages = [];
 		var sum = 0;
 		var pct;

 		arr.forEach(function(diff,ind){
 			sum = sum + diff;
 			avg = sum/(ind + 1);
 			pct = diff/avg;
 			percentages.push(pct);

 		})
 		return percentages;

 	}

 	var cluster_buildings = function(numbers){
 		//find a better, machine learning k means clustering way to do this later

 		var sorted = numbers.sort(function(a,b){
 			if(a>b){return 1} return -1;
 		});
 		// console.log("SORTED " + sorted)
 		
 		var differences = [];
 		for(var i =1; i < sorted.length; i++){
 			differences.push(sorted[i] - sorted[i-1]);
 		}
 		// console.log("SORTEDX " + sorted);
 		

 		// var sum_of_differences = differences.reduce(function(a,b){return a+b;})

 		// var percentage_of_differences = differences.map(function(num){return num/sum_of_differences})
// 
 		 var percentage_of_differences = get_percentage_of_differences(differences);
 		
 		 // console.log("END_RESULT" + percentage_of_differences)
 		

 		var sorted_percentage_of_differences = copy_then_sort_array_max_to_lowest(percentage_of_differences);

 		// console.log("SORTED DIFFS " + sorted_percentage_of_differences);

 		var n = sorted.length/2;

 	//	var curr_amount_difference_between_clusters = 0;
 		var curr_max_goodness;
 		var num_break_points;
 		var goodness;

 		var differences = {};

 		var indexes_to_split_clusters_at = {};
 		// console.log()
 		for(var j=1;j<n;j++){
 		//	curr_amount_difference_between_clusters = curr_amount_difference_between_clusters + sorted_percentage_of_differences[i];
 			goodness = sorted_percentage_of_differences[j] - sorted_percentage_of_differences[j-1]
 			// console.log("index " + j)
 			if(curr_max_goodness<Math.abs(goodness) || curr_max_goodness === undefined){
 				curr_max_goodness = Math.abs(goodness);
 				// console.log("GOODNESS " + goodness)
 				num_break_points = j;
 			}
 		}
 		// console.log("MAX GOOD" + curr_max_goodness)
 		// console.log("Clusters " + num_clusters)

 		for(var k = 0;k<num_break_points;k++){
 			differences[sorted_percentage_of_differences[k]] = true;
 		}
 		 
 		// console.log("DIFFS " + JSON.stringify(differences));

 		for(var l = 0;l<percentage_of_differences.length;l++){
 			if(differences[percentage_of_differences[l]]){
 				indexes_to_split_clusters_at[l] = true;
 			}
 		}

 		var clusters = [];
 		var curr_cluster = []
 		for(var m = 0; m<sorted.length;m++){
 			curr_cluster.push(sorted[m]);
 			if(indexes_to_split_clusters_at[m]){
 				clusters.push(curr_cluster);
 				curr_cluster = [];
 			}
 		}

 		clusters.push(curr_cluster);

 		return clusters
 		

 	}

 	function copy_then_sort_array_max_to_lowest(arr){
 		var new_arr = [];
 		arr.forEach(function(num){
 			new_arr.push(num);
 		})

 		new_arr.sort(function(a,b){
 			if(a<b){return 1} return -1;
 		});
 		// console.log("ARR " + new_arr)

 		return new_arr;
 	}

</script>
<script>
	 var segment_length = function(node1,node2){
 		var lat_diff = Math.abs(node1[0] - node2[0]);

 		var long_diff = Math.abs(node1[1] - node2[1]);

 		var seg_length = Math.sqrt(lat_diff*lat_diff + long_diff*long_diff)
 		// console.log(lat_diff*lat_diff)
 		return seg_length
 	}

 	 var get_perimeter = function(nodes){
 	 	var perimeter = 0
 	 	var seg_length;
 	 	for(var i = 1;i<nodes.length;i++){
 	 		seg_length = segment_length(nodes[i-1],nodes[i]);
 	 		perimeter = perimeter + seg_length;
 	 	}
 	 	return perimeter;
 	}

 	
</script>

<script>
//PERFORM ANALYSIS OF NETWORK

function distance_between_two_lat_longs(latlong1,latlong2){
	var lat_dist = Math.abs(latlong1[0] - latlong2[0]);
	var long_dist = Math.abs(latlong1[1] - latlong2[1]);
	return Math.sqrt((lat_dist*lat_dist) + (long_dist*long_dist))
}


function assign_center_to_buildings(building_array){
	var nodes;

	building_array.forEach(function(building){
		
		nodes = building["nodes"];
		building["center_lat_long"] = get_center(nodes);
	})
}

function get_center(nodes){
	var num_nodes = nodes.length;
	var lat_sum = 0;
	var long_sum = 0;
	nodes.forEach(function(node){
		lat_sum += node[0];
		long_sum += node[1];
	})


	var lat_center = lat_sum/num_nodes;
	var long_center = long_sum/num_nodes;
	return [lat_center,long_center]
}


function assign_served_buildings_to_substation(substation_array,array_all_buildings){

	var closest_substation;

	var distance;
	var smallest_distance = Infinity;

	array_all_buildings.forEach(function(building,ind){
		smallest_distance = Infinity;
		substation_array.forEach(function(substation){
			distance = distance_between_two_lat_longs(building["center_lat_long"],substation["center_lat_long"])
			if(distance < smallest_distance){
				smallest_distance = distance;
				closest_substation = substation;
			}
		})
		// console.log(closest_substation)
		closest_substation["buildings_served"].push(building);
		building["closest_substation"] = closest_substation;
	})


}

function map_outer_ring(substation){
	var nodes_in_ring = substation["outer-ring"].map(function(building){return building["center_lat_long"]});
	// console.log(nodes_in_ring)
	polygon = L.polygon(nodes_in_ring,{color: 'yellow'}).addTo(mymap);
}

function map_served_buildings(){
	var convexHull = new ConvexHullGrahamScan();
	var hullPoints;
	var nodes;

	substations.forEach(function(substation){

		substation.buildings_served.forEach(function(building){var center = building["center_lat_long"],lat = center[0], long = center[1];convexHull.addPoint(lat,long);});

		hullPoints = convexHull.getHull();

		nodes = hullPoints.map(function(point){return [point.x,point.y]});

		nodes.push(nodes[0]);

		L.polyline(nodes).addTo(mymap,{"color":'green'});
	})
}

function go(){

	power_data["Ways"].forEach(function(way,index){populate_way(way,index)});

	assign_center_to_buildings(buildings)
	assign_center_to_buildings(substations)
	assign_served_buildings_to_substation(substations,buildings)
	// map_served_buildings();

	// substations[0].buildings_served.forEach(function(building){building['polygon'].setStyle({color:'yellow'})})
}

//GRID ANALYSIS

class Grid_Box {
		//class for one half mile square on map
		//records contained buildings
		//records contained substations
		//records number of unserved buildings
		//records all adjacent neighbors in an array of neighboring boxes
		//has a function is present in grid box that takes a lat long and return if that lat long (usually the center of a building) is in this box
		//has a function add to buildings contained
		//has a function add to substations contained
		//has a function update unserved buildings
		//has a function add guessed substation
		//has a function update unserved buildings
		constructor(left,bottom,right,top){

			this.left = left;
			this.bottom = bottom;
			this.right = right;
			this.top = top;
			this.contained_buildings = [];
			this.contained_substations = [];
			this.rectangle;
			this.unserved_buildings;
			this.contained_and_adjacent_subs;
			this.adjacent_boxes = [];

			this.highlight = function(){
				this.rectangle.setStyle({fillColor:"yellow"})
			}

			this.random_building = function(){
				var rand_index = Math.floor(Math.random() * this.contained_buildings.length);
				return this.contained_buildings[rand_index]
 			}

 			this.add_guessed_substation = function(){
 				var rand_building = this.random_building();
 				rand_building.guessed_sub = true;
 				substations.push(rand_building);
 				guessed_substations.push(rand_building);
 				this.contained_substations.push(rand_building);
 				rand_building.draw();
 				this.update_num_unserved();
 				this.adjacent_boxes.forEach(function(box){
 					box.update_num_unserved();
 				})
 			}

			this.find_adjacent_boxes = function(){
				var that = this;
				var half_mile =  .007246;
				
				grid.forEach(function(box){
					var bottom_dif = Math.abs(box.bottom - that.bottom);
					var top_dif = Math.abs(box.top - that.top);
					var left_dif = Math.abs(box.left - that.left);
					var right_dif = Math.abs(box.right - that.right);
					var difs = [bottom_dif,top_dif,left_dif,right_dif];
					var filtered = difs.filter(function(dif){return dif > (half_mile + .000001)});
					var sum = difs.reduce(function(a,b){return a + b;})
					if(filtered.length === 0 && sum>0){
						that.adjacent_boxes.push(box);
					}
				})
			}

			this.draw = function(){
				var bounds = [[this.bottom,this.left],[this.top,this.right]]
				this.rectangle = L.rectangle(bounds, {color: "green", weight: 1});
				this.rectangle.addTo(mymap);
			}

			this.is_present_in_box = function(lat_long){
				var lat = lat_long[0];
				var long = lat_long[1];

				if(lat > this.bottom && lat < this.top){
					if(long > this.left && long < this.right){
						return true;
					}
				}
				return false;
			}

			this.iterate_buildings_and_add_contained_buildings = function(){
				var that = this;
				buildings.forEach(function(building){
					if(that.is_present_in_box(building.center_lat_long) && that.contained_buildings.includes(building) === false){
						that.contained_buildings.push(building);
					}
				})
			}

			this.iterate_and_add_substations = function(){
				var that = this;
				substations.forEach(function(building){
					if(that.is_present_in_box(building.center_lat_long)){
						that.contained_substations.push(building);
						building.grid_box = that;
					}
				})
			}

			this.update_num_unserved = function(){
				var contained_subs = this.contained_substations.length;
				var adjacent_subs = 0;
				this.adjacent_boxes.forEach(function(box){
					adjacent_subs = adjacent_subs + box.contained_substations.length;
				})
				var total_subs = contained_subs + adjacent_subs;

				this.contained_and_adjacent_subs = total_subs;
				this.unserved_buildings = this.contained_buildings.length - (this.contained_and_adjacent_subs * 125)

				// var
			}

		}

	}

	class Grid{
		constructor(grid_array){
			this.grid_array = grid;

			this.sort_by_unserved = function(){
				this.grid_array.sort(function(a,b){if(a.unserved_buildings > b.unserved_buildings){return 1} return -1})
			}

			this.sort_by_contained_buildings = function(){
				this.grid_array.sort(function(a,b){if(a.contained_buildings.length > b.contained_buildings.length){return 1} return -1})
			}

			this.guess_top_x = function(x){
				for(var i = 0; i < x; i++){
					this.sort_by_unserved();
					this.grid_array[grid_array.length-1].add_guessed_substation();
					this.sort_by_unserved();
				}
			}
		}
	}

//Script for grid analysis 
	function get_grid_boxes(bounds){
		var bottom = bounds[1][0]
		var left = bounds[0][1]
		var top = bounds[0][0]
		var right = bounds[1][1]
		console.log(bottom + "," + left + "," + right + "," + top)
		var half_mile =  .007246;

		var lat_dif = top-bottom;
		var long_dif = right - left;

		var num_rows = Math.ceil(lat_dif / half_mile);
		var num_columns = Math.ceil(long_dif / half_mile);
		console.log(num_rows)
		console.log(num_columns)

		var box_bottom;
		var box_left;
		var box_top;
		var box_right;
		var grid = [];

		for(var i = 0;i<num_rows;i++){
			for(var j = 0;j<num_columns;j++){
				box_left = left + (j * half_mile);
				box_bottom = bottom + (i * half_mile)
				box_right = box_left + half_mile;
				box_top = box_bottom + half_mile;
				grid.push(new Grid_Box(box_left,
					box_bottom,box_right,box_top));
			}	
		}
		return grid;
		//output one grid object of grid squares of one half mile in perimeter side
		//also draws grid boxes
	}
	var grid;

	function do_grid_analysis(){
		grid = get_grid_boxes(bounds);
		grid.forEach(function(box){box.draw()});
		grid.forEach(function(box){box.iterate_buildings_and_add_contained_buildings()});	
	}

	function go_and_do_analysis(){
		go();
		do_grid_analysis();
		grid.forEach(function(box){
			box.iterate_buildings_and_add_contained_buildings();
			box.iterate_and_add_substations();
			box.find_adjacent_boxes()
			
		})
		grid.forEach(function(box){
			box.update_num_unserved()
		})
		grid = new Grid(grid);
		grid.sort_by_unserved();
		substations.forEach(function(station){station.draw()})
	}




</script>


</body>
</html>