
<!DOCTYPE html>
<html>
<head>
	
	<title>Quick Start - Leaflet</title>

	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ==" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js" integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw==" crossorigin=""></script>

    <script
  src="https://code.jquery.com/jquery-3.2.1.js"
  integrity="sha256-DZAnKJ/6XZ9si04Hgrsxu/8s717jcIzLy3oi35EouyE="
  crossorigin="anonymous"></script>
 



	
</head>
<body>



<div id="mapid" style="width: 1800px; height: 1200px;"></div>
<script>


	var mymap = L.map('mapid').setView([51.505, -0.09], 13);


	L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', {
		maxZoom: 18,
		attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
			'<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
			'Imagery Â© <a href="http://mapbox.com">Mapbox</a>',
		id: 'mapbox.streets'
	}).addTo(mymap);

	// L.marker([51.5, -0.09]).addTo(mymap)
	// 	.bindPopup("<b>Hello world!</b><br />I am a popup.").openPopup();

	// L.circle([51.508, -0.11], 500, {
	// 	color: 'red',
	// 	fillColor: '#f03',
	// 	fillOpacity: 0.5
	// }).addTo(mymap).bindPopup("I am a circle.");

	L.polygon([
		[51.509, -0.08],
		[51.503, -0.06],
		[51.51, -0.047]
	],{color: 'red'}).addTo(mymap)	

	// var popup = L.popup();

	class Building{
		constructor(metadata,nodes,tags){
			this.metadata = metadata;
			this.nodes = nodes;
			this.tags = tags;
		}
	}

	var buildings = [];
	var polygons = [];
	var polylines = [];
	var power_data;
	var polygon;
	var building;

	var draw_way = function(way_object){
		var nodes = [];
		var latlongs = way_object["node_references"].forEach(function(ref){
			if(ref["metadata"] !== undefined){
				var lat = parseFloat(ref["metadata"]["lat"]);
				var lon = parseFloat(ref["metadata"]["lon"].replace("/",""));

				nodes.push([lat,lon])
			}
		})
		var tags_string = JSON.stringify(way_object["tags"]);
		if(way_object["tags"]["power"] !== "substation"){
			console.log("Adding polyline " + JSON.stringify(nodes))
			polyline = L.polyline(nodes).addTo(mymap);
			polylines.push(polyline)
			polyline.bindPopup(tags_string);
		} else {
			polygon = L.polygon(nodes,{color: 'red'}).addTo(mymap)
			polygons.push(polygon)
			polygon.bindPopup(tags_string);
			building = new Building(way_object["metadata"],nodes,way_object["tags"])
			buildings.push(building);
		}


	}

	

	$.get("http://localhost:3000/latlong",function(data){
		 
		var bounds = JSON.parse(data);
		console.log(bounds[0]);
		// console.log(data);
		mymap.fitBounds(bounds);

	})

	var grid_boxes;

	var draw_grid = function(boxes_array){
		// console.log("ARR" + boxes_array);
		var left;
		var bottom;
		var right;
		var top;
		
		left = boxes_array[0];
		bottom = boxes_array[1];
		right = boxes_array[2];
		top = boxes_array[3];
		// console.log("FIRST" + left)
		var bound_box = [
			[top,left],
			[top,right],
			[bottom,right],
			[bottom,left],
			[top,left]

		]
		 // console.log("BOX AFTER" + bound_box);

		L.polygon(bound_box).addTo(mymap)


	}

	$.get("http://localhost:3000/boxes",function(data){
		// console.log("HERE1")
		boxes = JSON.parse(data);
		// console.log("boxes" + boxes);
		grid_boxes = boxes;
		boxes.forEach(function(box){
			// console.log('BOX' + typeof box);
			draw_grid(box);
		})
		// console.log(data);
		

	})

	$.get("http://localhost:3000/data",function(data){

		power_data = data;
		
		// console.log(data);
		

	})

</script>
<script>
//clustering algorithm for building perims
	var add_perimeters_to_buildings = function(){
		buildings.forEach(function(building){
			building["perimeter"] = get_perimeter(building["nodes"]);
		})
	}


 	// console.log(segment_length([1,2],[2,3]));

 	var get_percentage_of_differences = function(arr){
 		var percentages = [];
 		var sum = 0;
 		var pct;

 		arr.forEach(function(diff,ind){
 			sum = sum + diff;
 			avg = sum/(ind + 1);
 			pct = diff/avg;
 			percentages.push(pct);

 		})
 		return percentages;

 	}

 	var cluster_buildings = function(numbers){
 		//find a better, machine learning k means clustering way to do this later

 		var sorted = numbers.sort(function(a,b){
 			if(a>b){return 1} return -1;
 		});
 		// console.log("SORTED " + sorted)
 		
 		var differences = [];
 		for(var i =1; i < sorted.length; i++){
 			differences.push(sorted[i] - sorted[i-1]);
 		}
 		// console.log("SORTEDX " + sorted);
 		

 		// var sum_of_differences = differences.reduce(function(a,b){return a+b;})

 		// var percentage_of_differences = differences.map(function(num){return num/sum_of_differences})
// 
 		 var percentage_of_differences = get_percentage_of_differences(differences);
 		
 		 // console.log("END_RESULT" + percentage_of_differences)
 		

 		var sorted_percentage_of_differences = copy_then_sort_array_max_to_lowest(percentage_of_differences);

 		// console.log("SORTED DIFFS " + sorted_percentage_of_differences);

 		var n = sorted.length/2;

 	//	var curr_amount_difference_between_clusters = 0;
 		var curr_max_goodness;
 		var num_break_points;
 		var goodness;

 		var differences = {};

 		var indexes_to_split_clusters_at = {};
 		// console.log()
 		for(var j=1;j<n;j++){
 		//	curr_amount_difference_between_clusters = curr_amount_difference_between_clusters + sorted_percentage_of_differences[i];
 			goodness = sorted_percentage_of_differences[j] - sorted_percentage_of_differences[j-1]
 			// console.log("index " + j)
 			if(curr_max_goodness<Math.abs(goodness) || curr_max_goodness === undefined){
 				curr_max_goodness = Math.abs(goodness);
 				// console.log("GOODNESS " + goodness)
 				num_break_points = j;
 			}
 		}
 		// console.log("MAX GOOD" + curr_max_goodness)
 		// console.log("Clusters " + num_clusters)

 		for(var k = 0;k<num_break_points;k++){
 			differences[sorted_percentage_of_differences[k]] = true;
 		}
 		 
 		// console.log("DIFFS " + JSON.stringify(differences));

 		for(var l = 0;l<percentage_of_differences.length;l++){
 			if(differences[percentage_of_differences[l]]){
 				indexes_to_split_clusters_at[l] = true;
 			}
 		}

 		var clusters = [];
 		var curr_cluster = []
 		for(var m = 0; m<sorted.length;m++){
 			curr_cluster.push(sorted[m]);
 			if(indexes_to_split_clusters_at[m]){
 				clusters.push(curr_cluster);
 				curr_cluster = [];
 			}
 		}

 		clusters.push(curr_cluster);

 		return clusters
 		

 	}

 	function copy_then_sort_array_max_to_lowest(arr){
 		var new_arr = [];
 		arr.forEach(function(num){
 			new_arr.push(num);
 		})

 		new_arr.sort(function(a,b){
 			if(a<b){return 1} return -1;
 		});
 		// console.log("ARR " + new_arr)

 		return new_arr;
 	}

</script>
<script>
	 var segment_length = function(node1,node2){
 		var lat_diff = Math.abs(node1[0] - node2[0]);

 		var long_diff = Math.abs(node1[1] - node2[1]);

 		var seg_length = Math.sqrt(lat_diff*lat_diff + long_diff*long_diff)
 		// console.log(lat_diff*lat_diff)
 		return seg_length
 	}

 	 var get_perimeter = function(nodes){
 	 	var perimeter = 0
 	 	var seg_length;
 	 	for(var i = 1;i<nodes.length;i++){
 	 		seg_length = segment_length(nodes[i-1],nodes[i]);
 	 		perimeter = perimeter + seg_length;
 	 	}
 	 	return perimeter;
 	}

 	
</script>



</body>
</html>